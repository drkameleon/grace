<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="lib/bulma/bulma.min.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="lib/xterm/xterm.min.css" media="print" onload="this.media='all'">
    <style>
        /* Variables */
        :root {
            --modal-bg: #fff;
            --modal-border: #eee;
            --text-color: #666;
            --hover-bg: rgba(0,0,0,0.05);
            --modal-overlay: rgba(0, 0, 0, 0.2);
            --statusbar-bg: #f5f5f5;
            --statusbar-border: #ddd;
            --statusbar-divider: #ddd;
            --spinner-track: #f3f3f3;
            --spinner-active: #41B883;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --modal-bg: #2c2c2c;
                --modal-border: #444;
                --text-color: #ccc;
                --hover-bg: rgba(255,255,255,0.05);
                --modal-overlay: rgba(0, 0, 0, 0.4);
                --statusbar-bg: #1c1c1c;
                --statusbar-border: #333;
                --statusbar-divider: #333;
                --modal-header-text: #fff;
                --input-bg: #3a3a3a;
                --input-text: #fff;
                --label-text: #bbb;
                --checkbox-text: #ddd;
                --slider-text: #ddd;
                --spinner-track: #2C2C2C;
                --spinner-active: #41B883;
            }
        }

        /* Base */
        * { user-select: none; -webkit-user-select: none; overscroll-behavior: none;}

        /* Editor */
        #editor { 
            position: absolute;
            top: 0;
            right: 0;
            bottom: 40px;
            left: 0;
            user-select: text;
            -webkit-user-select: text;
        }

        /* Status Bar Base */
        #statusbar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background-color: var(--statusbar-bg);
            border-top: 1px solid var(--statusbar-border);
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            z-index: 20; /* Ensure it's above other elements */
        }

        /* Left side with position info */
        .position-info {
            display: flex;
            align-items: center;
            color: var(--text-color);
            font-size: 0.875rem;
            min-width: 0;
            cursor: default;
        }

        .position-info span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 15px;
        }

        /* Right side controls */
        .controls {
            display: flex;
            height: 100%;
            align-items: stretch;
        }

        /* Settings button */
        .settings-button {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            border-right: 1px solid var(--statusbar-divider);
            height: 100%;
            transition: width 0.2s;
            cursor: pointer;
            width: 42px; /* Default width */
        }

        .settings-button:hover {
            background-color: var(--hover-bg);
        }

        .settings-button svg {
            width: 16px;
            height: 16px;
            color: var(--text-color);
        }

        /* Control Items (Select wrappers and terminal button) */
        .select-wrapper {
            position: relative;
            height: 100%;
            border-left: 1px solid var(--statusbar-divider);
            display: flex;
            align-items: center;
            padding: 0 15px;
        }


        .select-wrapper::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid var(--text-color);
            pointer-events: none;
        }

        .select-wrapper select {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 0.875rem;
            cursor: pointer;
            padding-right: 15px;
            -webkit-appearance: none;
            appearance: none;
        }

        .select-wrapper select:focus {
            outline: none;
        }

        /* Terminal button */
        .terminal-button {
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid var(--statusbar-divider);
            cursor: pointer;
            padding: 0 15px;
            height: 100%;
        }

        .terminal-button:hover {
            background-color: var(--hover-bg);
        }

        .terminal-button svg {
            width: 16px;
            height: 16px;
            color: var(--text-color);
        }

        /* Modal */
        .modal-background {
            background-color: var(--modal-overlay) !important;
        }

        .modal-card {
            width: 400px;
            margin: 0 auto;
            margin-top: 10px !important;
        }

        .modal-card-head {
            padding: 10px 15px;
            background: var(--modal-bg);
        }

        .modal-card-title {
            font-size: 1rem;
            color: var(--modal-header-text);
        }

        .modal-card-body {
            padding: 20px 25px;
            background: var(--modal-bg);
        }

        .modal-card-foot {
            padding: 10px 15px;
            justify-content: flex-end;
            background: var(--modal-bg);
            border-top: 1px solid var(--modal-border);
        }

        .modal-card-foot .button {
            background: transparent;
            border: none;
            color: var(--text-color);
            height: 2em;
            padding: 0 1em;
        }

        .modal-card-foot .button:hover {
            background: var(--hover-bg);
        }

        /* Settings Form */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-row label {
            color: var(--label-text);
            font-size: 0.9em;
        }

        .setting-row select {
            width: 200px;
            padding: 6px 12px;
            border: 1px solid var(--statusbar-divider);
            border-radius: 4px;
            background-color: var(--input-bg);
            color: var(--input-text);
            font-size: 0.9em;
            appearance: none;
        }

        .setting-row select:hover {
            border-color: #4a9eff;
        }

        .setting-row select:focus {
            outline: none;
            border-color: #4a9eff;
            box-shadow: 0 0 0 1px #4a9eff;
        }

        /* Remove gradient from select in WebKit */
        .setting-row select {
            background-image: none;
        }

        /* Custom dropdown arrow */
        .setting-row {
            position: relative;
        }

        .setting-row:has(select)::after {
            content: "";
            position: absolute;
            right: 12px;
            top: 50%;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid var(--text-color);
            pointer-events: none;
        }

        /* Font Size Control */
        .font-size-control {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 200px;
            justify-content: space-between;
        }

        /* Slider styling */
        .font-size-control input[type="range"] {
            -webkit-appearance: none;
            background: var(--input-bg);
            border: 1px solid var(--statusbar-divider);
            border-radius: 4px;
            height: 8px;
            width: 140px;
        }

        /* Hover state */
        .font-size-control input[type="range"]:hover {
            border-color: #4a9eff;
        }

        /* Focus state */
        .font-size-control input[type="range"]:focus {
            outline: none;
            border-color: #4a9eff;
            box-shadow: 0 0 0 1px #4a9eff;
        }

        /* Thumb styling */
        .font-size-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 4px;
            background: #4a9eff;
            cursor: pointer;
            border: none;
            transition: transform 0.1s ease;
        }

        /* Thumb hover effect */
        .font-size-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .font-size-control span {
            color: var(--slider-text);
            min-width: 40px; /* Ensure consistent width */
            text-align: right;
        }

        /* Word Wrap Toggle */
        .word-wrap-toggle {
            display: flex;
            align-items: center;
        }

        .word-wrap-toggle input[type="checkbox"] {
            margin-right: 8px;
        }

        .word-wrap-toggle span {
            color: var(--checkbox-text);
        }

        /* Checkbox styling */
        .word-wrap-toggle input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid var(--statusbar-divider);
            border-radius: 4px;
            background: var(--input-bg);
            cursor: pointer;
            position: relative;
            margin-right: 8px;
        }

        /* Add hover styles to match select dropdowns */
        .word-wrap-toggle input[type="checkbox"]:hover {
            border-color: #4a9eff;
        }

        /* Add focus styles to match select dropdowns */
        .word-wrap-toggle input[type="checkbox"]:focus {
            outline: none;
            border-color: #4a9eff;
            box-shadow: 0 0 0 1px #4a9eff;
        }

        .word-wrap-toggle input[type="checkbox"]:checked {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .word-wrap-toggle input[type="checkbox"]:checked::after {
            content: "";
            position: absolute;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--modal-bg);
            z-index: 9999;
            transition: background-color 0.3s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--spinner-track);
            border-top: 5px solid var(--spinner-active);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        .loading-text {
            margin-top: 20px;
            color: var(--text-color);
            font-size: 16px;
            transition: color 0.3s ease;
        }

        /* Dark mode overrides for Bulma */
        @media (prefers-color-scheme: dark) {
            .hero.is-fullheight {
                background-color: var(--modal-bg);
            }
            
            .hero-body {
                background-color: var(--modal-bg);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .fade-out {
            animation: fadeOut 0.5s ease-in-out forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .terminal-drawer {
            display: none; /* Completely hide the drawer initially */
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            background-color: var(--modal-bg);
            border-top: 1px solid var(--statusbar-border);
            transition: transform 0.3s ease;
            z-index: 10;
            height: 200px;
            max-height: calc(50vh - 40px);
            flex-direction: column;
        }

        .terminal-drawer.is-open {
            display: flex; /* Show the drawer when open */
            transform: translateY(0);
        }

        .terminal-content {
            flex: 1;
            min-height: 0;
            position: relative;
            overflow: hidden;
        }

        .terminal-content .terminal {
            height: 100% !important;
            padding: 8px;
        }

        /* Ensure the canvas takes full height */
        .terminal-content .terminal > div {
            height: 100%;
        }

        .terminal-content .xterm-viewport {
            overflow-y: auto !important;
            overflow-x: hidden !important;
        }

        /* Adjust xterm scrollbar for dark mode */
        @media (prefers-color-scheme: dark) {
            .terminal-content .xterm-viewport::-webkit-scrollbar {
                width: 8px;
            }

            .terminal-content .xterm-viewport::-webkit-scrollbar-track {
                background: var(--modal-bg);
            }

            .terminal-content .xterm-viewport::-webkit-scrollbar-thumb {
                background: var(--text-color);
                opacity: 0.5;
                border-radius: 4px;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-container">
        <div class="hero is-fullheight">
          <div class="hero-body">
            <div class="container has-text-centered">
              <div class="spinner"></div>
              <div class="loading-text">Loading...</div>
            </div>
          </div>
        </div>
      </div>
    <div id="app">
        <div id="editor"></div>
        <div id="terminal-drawer" 
            class="terminal-drawer" 
            :class="{ 'is-open': isTerminalOpen }" 
            :style="{ height: `${terminalHeight}px` }">
            <div class="terminal-handle">
                <div class="handle-line"></div>
            </div>
            <div class="terminal-content">
            </div>
        </div>
        <div id="statusbar">
            <div class="position-info">
                <div class="settings-button" @click="openSettingsModal">
                    <i data-lucide="settings"></i>
                </div>
                <span>Line: {{ cursor.row }}, Column: {{ cursor.column }}</span>
            </div>
            <div class="controls">
                <div class="select-wrapper">
                    <select v-model="indentSize">
                        <option v-for="size in [1,2,4,8]" :value="size">{{ size }}</option>
                    </select>
                </div>
                <div class="select-wrapper">
                    <select v-model="indentType">
                        <option value="spaces">Spaces</option>
                        <option value="tabs">Tabs</option>
                    </select>
                </div>
                <div class="select-wrapper">
                    <select v-model="syntax">
                        <option 
                            v-for="[value, label] in Object.entries(syntaxes).sort((a, b) => a[1].localeCompare(b[1]))" 
                            :key="value" 
                            :value="value"
                        >
                            {{ label }}
                        </option>
                    </select>
                </div>
                <div class="terminal-button" @click="toggleTerminal">
                    <i data-lucide="terminal"></i>
                </div>
            </div>
        </div>
     
        <div class="modal" :class="{'is-active': isSettingsModalOpen}">
            <div class="modal-background" @click="closeSettingsModal"></div>
            <div class="modal-card">
                <header class="modal-card-head">
                    <p class="modal-card-title">Settings</p>
                    <button class="delete is-small" @click="closeSettingsModal"></button>
                </header>
                <section class="modal-card-body">
                    <div class="setting-row">
                        <label>Font Family</label>
                        <select v-model="selectedFont">
                            <option v-for="font in availableFonts" :value="font">{{ font }}</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Font Size</label>
                        <div class="font-size-control">
                            <input type="range" v-model="fontSize" min="8" max="24" step="1">
                            <span>{{ fontSize }}px</span>
                        </div>
                    </div>
                    <div class="setting-row">
                        <label>Theme</label>
                        <select v-model="theme">
                            <optgroup label="Dark Themes">
                                <option 
                                    v-for="[value, label] in Object.entries(darkThemes).sort((a, b) => a[1].localeCompare(b[1]))" 
                                    :key="value"
                                    :value="value">
                                        {{ label }}
                                </option>
                            </optgroup>
                            <optgroup label="Light Themes">
                                <option 
                                    v-for="[value, label] in Object.entries(lightThemes).sort((a, b) => a[1].localeCompare(b[1]))" 
                                    :key="value"
                                    :value="value">
                                        {{ label }}
                                </option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Word Wrap</label>
                        <div class="word-wrap-toggle">
                            <input type="checkbox" v-model="wordWrap">
                            <span>Enable word wrapping</span>
                        </div>
                    </div>
                </section>
                <footer class="modal-card-foot">
                    <button class="button is-small" @click="restoreDefaults">
                        <i data-lucide="rotate-ccw" class="icon is-small mr-1"></i>
                        Restore Defaults
                    </button>
                </footer>
            </div>
        </div>
    </div>
    <script src="lib/ace/ace.js"></script>
    <script src="lib/arturo/arturo.js"></script>
    <script src="lib/vue/vue.global.prod.min.js"></script>
    <script src="lib/xterm/xterm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/3.14.5/addons/fit/fit.js"></script>
    <script src="lib/lucide/lucide.js"></script>
    <script>
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const { createApp, onMounted, ref, watch, nextTick } = Vue;

        createApp({
            setup() {
                const editor = ref(null);
                const cursor = ref({ row: 1, column: 1 });
                const isSettingsModalOpen = ref(false);
                const syntax = ref('javascript');
                const theme = ref('monokai');
                const indentSize = ref(4);
                const indentType = ref('spaces');
                const fontSize = ref(14);
                const selectedFont = ref('Monaco');
                const availableFonts = ref([]);
                const wordWrap = ref(false);

                const syntaxes = ref({});

                const defaultSettings = {
                    theme: 'monokai',
                    fontSize: 14,
                    selectedFont: 'Monaco',
                    wordWrap: false
                };

                const darkThemes = ref({});
                const lightThemes = ref({});

                const isTerminalOpen = ref(false);
                const terminalHeight = ref(200); // Default height in pixels

                const terminal = ref(null);

                function getThemeColors(editorTheme) {
                    // Map Ace themes to terminal colors
                    const isDark = Object.keys(darkThemes.value).includes(editorTheme);
                    
                    return {
                        background: isDark ? '#1a1a1a' : '#ffffff',
                        foreground: isDark ? '#f0f0f0' : '#000000',
                        cursor: isDark ? '#f0f0f0' : '#000000',
                        selection: isDark ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)',
                        black: isDark ? '#000000' : '#000000',
                        red: '#ff5555',
                        green: '#50fa7b',
                        yellow: '#f1fa8c',
                        blue: '#bd93f9',
                        magenta: '#ff79c6',
                        cyan: '#8be9fd',
                        white: isDark ? '#f8f8f2' : '#ffffff',
                        brightBlack: '#6272a4',
                        brightRed: '#ff6e6e',
                        brightGreen: '#69ff94',
                        brightYellow: '#ffffa5',
                        brightBlue: '#d6acff',
                        brightMagenta: '#ff92df',
                        brightCyan: '#a4ffff',
                        brightWhite: isDark ? '#ffffff' : '#000000'
                    };
                }

                function initializeTerminal() {
                    const colors = getThemeColors(theme.value);
                    
                    // Add command history array and index
                    const commandHistory = [];
                    let historyIndex = -1;
                    let currentInput = '';

                    terminal.value = new Terminal({
                        cursorBlink: true,
                        fontSize: 14,
                        fontFamily: 'Monaco, Menlo, Consolas, monospace',
                        theme: colors,
                        convertEol: true,
                        scrollback: 5000,
                        disableStdin: false,
                        cursorStyle: 'block',
                        allowTransparency: true,
                        rows: 20,
                        copyOnSelect: true    // Enable copy on selection
                    });

                    // Initialize fit addon
                    window.Terminal.applyAddon(window.fit);
                    
                    terminal.value.open(document.querySelector('.terminal-content'));
                    terminal.value.fit();
                    
                    // Initialize with prompt
                    terminal.value.write('\r\n$> ');

                    let currentLine = '';
                    let cursorPosition = 0;

                    // Helper to clear current line and rewrite
                    function rewriteLine(newLine) {
                        terminal.value.write('\x1b[2K\r$> ' + newLine);
                        currentLine = newLine;
                        cursorPosition = newLine.length;
                    }

                    terminal.value.onKey(({ key, domEvent }) => {
                        const printable = !domEvent.altKey && !domEvent.altGraphKey && !domEvent.ctrlKey && !domEvent.metaKey;
                        
                        if (domEvent.keyCode === 13) { // Enter
                            if (currentLine.trim() !== '') {
                                commandHistory.push(currentLine);  // Add to history
                                historyIndex = commandHistory.length;  // Reset history index
                            }
                            
                            arturo.call("executeCode", currentLine).then((res) => {
                                if (res.ok) {
                                    if (res.content !== null) {
                                        terminal.value.write("\r\n\x1b[2;37m=> " + res.content + "\x1b[0m");
                                    }
                                }
                                else {
                                    terminal.value.write("\r\n\x1b[2;31m!! " + res.content + "\x1b[0m");
                                }
                                terminal.value.write('\r\n\r\n$> ');
                                currentLine = '';
                                cursorPosition = 0;
                            });
                            
                        } else if (domEvent.keyCode === 8) { // Backspace
                            if (currentLine.length > 0 && cursorPosition > 0) {
                                currentLine = currentLine.slice(0, -1);
                                cursorPosition--;
                                terminal.value.write('\b \b');
                            }
                        } else if (domEvent.keyCode === 38) { // Up arrow
                            if (historyIndex > 0) {
                                historyIndex--;
                                rewriteLine(commandHistory[historyIndex]);
                            }
                        } else if (domEvent.keyCode === 40) { // Down arrow
                            if (historyIndex < commandHistory.length - 1) {
                                historyIndex++;
                                rewriteLine(commandHistory[historyIndex]);
                            } else {
                                historyIndex = commandHistory.length;
                                rewriteLine('');
                            }
                        } else if (domEvent.ctrlKey && domEvent.key === 'c') { // Ctrl+C
                            // If there's selected text, the browser will handle the copy
                            // If not, we can add our own behavior here
                            if (!terminal.value.hasSelection()) {
                                terminal.value.write('^C\r\n$> ');
                                currentLine = '';
                                cursorPosition = 0;
                            }
                        } else if (domEvent.ctrlKey && domEvent.key === 'v') { // Ctrl+V
                            // Read from clipboard and write to terminal
                            navigator.clipboard.readText().then(text => {
                                currentLine += text;
                                cursorPosition += text.length;
                                terminal.value.write(text);
                            }).catch(err => {
                                console.warn('Failed to read clipboard:', err);
                            });
                        } else if (printable) {
                            currentLine += key;
                            cursorPosition++;
                            terminal.value.write(key);
                        }
                    });

                    // Add selection changed handler for copy feedback (optional)
                    terminal.value.onSelectionChange(() => {
                        if (terminal.value.hasSelection()) {
                            // You could add visual feedback here if desired
                            console.log('Text selected');
                        }
                    });
                }

                function toggleTerminal() {
                    isTerminalOpen.value = !isTerminalOpen.value;
                    
                    // Initialize terminal if it's being opened for the first time
                    if (isTerminalOpen.value && !terminal.value) {
                        nextTick(() => {
                            initializeTerminal();
                        });
                    }
                    
                    // Fit terminal to container when opened
                    if (isTerminalOpen.value && terminal.value) {
                        nextTick(() => {
                            //terminal.value.fit();
                        });
                    }
                }

                const handleTerminalResize = debounce(() => {
                    if (terminal.value) {
                        terminal.value.fit();
                        terminal.value.scrollToBottom();
                    }
                }, 50);  // 50ms debounce

                function initializeTerminalResize() {
                    const drawer = document.querySelector('.terminal-drawer');
                    const handle = document.querySelector('.terminal-handle');
                    let startY, startHeight;

                    handle.addEventListener('mousedown', (e) => {
                        startY = e.clientY;
                        startHeight = parseInt(getComputedStyle(drawer).height);
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    });

                    function handleMouseMove(e) {
                        const delta = startY - e.clientY;
                        const newHeight = Math.min(
                            Math.max(100, startHeight + delta), // Min height of 100px
                            window.innerHeight * 0.5 - 40 // Max 50% of viewport minus statusbar
                        );
                        drawer.style.height = `${newHeight}px`;
                        terminalHeight.value = newHeight;
                    }

                    function handleMouseUp() {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    }
                }

                async function detectMonospaceFonts() {
                    // Only the fonts from your Font Book listing
                    var allFonts = [];
                    try {
                        const response = await fetch('data/fonts.art');
                        allFonts = await response.json();
                    } catch (error) {
                        console.log(error);
                    }
                    
                    const fonts = await Promise.all(
                        allFonts.map(async font => {
                            try {
                                const fontFace = new FontFace(font, `local("${font}")`);
                                await fontFace.load();
                                return font;
                            } catch {
                                return null;
                            }
                        })
                    );
                    
                    return fonts.filter(font => font !== null);
                }

                function updateSettingsButtonWidth() {
                    const gutter = document.querySelector('.ace_gutter');
                    if (gutter) {
                        document.querySelector('.settings-button').style.width = gutter.offsetWidth + 'px';
                    }
                }

                function openSettingsModal() {
                    isSettingsModalOpen.value = true;
                }

                function closeSettingsModal() {
                    isSettingsModalOpen.value = false;
                }

                function restoreDefaults() {
                    theme.value = defaultSettings.theme;
                    fontSize.value = defaultSettings.fontSize;
                    selectedFont.value = defaultSettings.selectedFont;
                    wordWrap.value = defaultSettings.wordWrap;
                }

                function reformatIndentation(editor, size, type) {
                    const session = editor.session;
                    const lines = session.doc.getAllLines();
                    const useSpaces = type === 'spaces';
                    
                    // Store cursor position
                    const cursorPosition = editor.getCursorPosition();
                    
                    lines.forEach((line, index) => {
                        // Count leading whitespace
                        const match = line.match(/^\s*/);
                        if (match) {
                            const indentLevel = match[0].length / session.getTabSize();
                            const newIndent = useSpaces ? 
                                ' '.repeat(Math.floor(indentLevel) * size) : 
                                '\t'.repeat(Math.floor(indentLevel));
                            
                            // Replace the line's indentation
                            const newLine = newIndent + line.trimLeft();
                            session.doc.removeFullLines(index, index);
                            session.doc.insertFullLines(index, [newLine]);
                        }
                    });
                    
                    // Restore cursor position
                    editor.moveCursorToPosition(cursorPosition);
                }

                // Define the function inside Vue
                const openFile = (fname, fcontent, fsyntax) => {
                    if (editor.value) {
                        editor.value.setValue(fcontent);
                        editor.value.clearSelection();
                        syntax.value = fsyntax;
                    }
                };

                // Expose it globally
                window.V = window.V || {};
                window.V.openFile = openFile;

                onMounted(async () => {
                    try {
                        const response = await fetch('data/syntaxes.d.art');
                        syntaxes.value = await response.json();
                    } catch (error) {
                        console.log(error);
                    }

                    try {
                        const response = await fetch('data/themes.dark.d.art');
                        darkThemes.value = await response.json();
                    } catch (error) {
                        console.log(error);
                    }

                    try {
                        const response = await fetch('data/themes.light.d.art');
                        lightThemes.value = await response.json();
                    } catch (error) {
                        console.log(error);
                    }

                    editor.value = ace.edit("editor");
                    editor.value.setTheme("ace/theme/monokai");
                    editor.value.session.setMode("ace/mode/javascript");
                    editor.value.setFontSize(14);

                    editor.value.selection.on('changeCursor', () => {
                        const pos = editor.value.getCursorPosition();
                        cursor.value = {
                            row: pos.row + 1,
                            column: pos.column + 1
                        };
                    });

                    lucide.createIcons();

                    setTimeout(updateSettingsButtonWidth, 100);
                    editor.value.session.on('change', () => setTimeout(updateSettingsButtonWidth, 0));
                    editor.value.session.on('changeScrollLeft', updateSettingsButtonWidth);
                    editor.value.renderer.on('resize', updateSettingsButtonWidth);
                    editor.value.session.on('changeScrollTop', updateSettingsButtonWidth);

                    editor.value.setValue(`function helloGrace() {
    console.log("Hello, Grace!");
    return "Hello!";
}`, -1);  // The -1 moves cursor to start

                    try {
                        availableFonts.value = await detectMonospaceFonts();
                        if (availableFonts.value.length === 0) {
                            availableFonts.value = ['monospace'];
                        }
                    } catch (e) {
                        console.error('Error detecting fonts:', e);
                        availableFonts.value = ['monospace'];
                    }

                    initializeTerminalResize();

                    const resizeObserver = new ResizeObserver(debounce(() => {
                        if (isTerminalOpen.value) {
                            handleTerminalResize();
                        }
                    }, 50));
                    
                    const terminalContent = document.querySelector('.terminal-content');
                    if (terminalContent) {
                        resizeObserver.observe(terminalContent);
                    }

                    setTimeout(() => {
                        hideLoadingScreen();
                    }, 100);
                });

                watch([syntax, theme, indentSize, indentType, fontSize, selectedFont, wordWrap], 
                    ([newSyntax, newTheme, newIndentSize, newIndentType, newFontSize, newFont, newWordWrap], oldValues) => {
                        if (editor.value) {
                            const prevIndentSize = oldValues?.[2];
                            const prevIndentType = oldValues?.[3];
                            
                            if (oldValues?.[1] !== newTheme) {
                                editor.value.setTheme(`ace/theme/${newTheme}`);
                                
                                // Force theme update by directly manipulating classes
                                const editorElement = editor.value.container;
                                const oldThemeClass = Array.from(editorElement.classList)
                                    .find(className => className.startsWith('ace-'));
                                if (oldThemeClass) {
                                    editorElement.classList.remove(oldThemeClass);
                                }
                                editorElement.classList.add(`ace-${newTheme}`);
                                
                                // Force a redraw
                                editor.value.renderer.updateFull(true);
                                requestAnimationFrame(() => {
                                    const textArea = editor.value.container.querySelector('textarea');
                                    if (textArea) {
                                        textArea.focus();
                                        editor.value.renderer.updateFull(true);
                                    }
                                });
                            }
                            
                            editor.value.session.setMode(`ace/mode/${newSyntax}`);
                            
                            // Handle indentation change
                            if (prevIndentSize !== newIndentSize || prevIndentType !== newIndentType) {
                                const session = editor.value.session;
                                
                                // First, set the new tab size
                                session.setTabSize(newIndentSize);
                                session.setUseSoftTabs(newIndentType === 'spaces');
                                
                                // Then, reindent the entire document
                                const lines = session.doc.getAllLines();
                                let cursorPos = editor.value.getCursorPosition();
                                
                                lines.forEach((line, index) => {
                                    if (line.trim().length > 0) { // Only process non-empty lines
                                        // First convert all indentation to spaces
                                        let spaceLine = session.doc.$lines[index];
                                        // Calculate the actual indentation level (how many levels deep)
                                        let indentLevel = 0;
                                        for (let i = 0; i < spaceLine.length; i++) {
                                            if (spaceLine[i] === ' ') indentLevel++;
                                            else if (spaceLine[i] === '\t') indentLevel += prevIndentSize || 4;
                                            else break;
                                        }
                                        indentLevel = Math.floor(indentLevel / (prevIndentSize || 4));
                                        
                                        // Create new indentation
                                        let newIndent;
                                        if (newIndentType === 'spaces') {
                                            newIndent = ' '.repeat(indentLevel * newIndentSize);
                                        } else {
                                            newIndent = '\t'.repeat(indentLevel);
                                        }
                                        
                                        // Replace the line
                                        let newLine = newIndent + line.trimLeft();
                                        session.doc.removeFullLines(index, index);
                                        session.doc.insertFullLines(index, [newLine]);
                                    }
                                });
                                
                                // Restore cursor position
                                editor.value.moveCursorToPosition(cursorPos);
                            }
                            
                            editor.value.setFontSize(parseInt(newFontSize));
                            editor.value.container.style.fontFamily = newFont;
                            editor.value.session.setUseWrapMode(newWordWrap);
                        }
                    }, { deep: true }
                );

                watch([theme], ([newTheme]) => {
                    if (terminal.value) {
                        const colors = getThemeColors(newTheme);
                        terminal.value.setOption('theme', colors);
                    }
                });

                return {
                    cursor,
                    isSettingsModalOpen,
                    syntax,
                    syntaxes,
                    theme,
                    indentSize,
                    indentType,
                    fontSize,
                    selectedFont,
                    availableFonts,
                    darkThemes,
                    lightThemes,
                    wordWrap,
                    openSettingsModal,
                    closeSettingsModal,
                    restoreDefaults,
                    isTerminalOpen,
                    terminalHeight,
                    toggleTerminal
                };
            }
        }).mount('#app');
    </script>
</body>
</html>